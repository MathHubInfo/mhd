from __future__ import annotations

import functools
import inspect

from django.db import models

from .codec import Codec

from typing import Any, Callable, Type


def codec_operator(
    constructor: Callable[..., list[tuple[Type[object], str]]]
) -> Callable[..., Type[Codec]]:
    """
    Turns the argument into a codec operator.
    A Codec Operator is a function that returns
    a pair of (codecClass, name).

    CodecClass should be a parent-less class
    representing a codec, and name should be
    the name of the dynamical generated
    class.
    """

    @functools.wraps(constructor)
    def wrapper(*args, **kwargs):
        clz, name = constructor(*args, **kwargs)
        return _make_applied_codec_operator(clz, name)

    return wrapper


def _make_applied_codec_operator(clz: Type[object], name: str) -> Type[Codec]:
    if models.Model in inspect.getmro(clz):
        raise ValueError(
            "Class generated by Codec Operator should not inherit from model"
        )

    # get the dict of the class and remove the appropriate properties
    clz_meta: dict[str, Any] = dict(clz.__dict__)

    # remove the module properties directly
    clz_meta.pop("__dict__")
    clz_meta.pop("__module__")
    clz_meta.pop("__weakref__")

    # extract the CodecMeta class
    CodecMeta = clz_meta.pop("Meta", object)

    # create a new Meta-class which inherits from the above two
    class Meta(Codec.Meta, CodecMeta):
        app_label = "mhd_data"

    # setup the property dictionary
    attrs: dict[str, Any] = {"__module__": "mhd_data.models.codecs", "Meta": Meta}
    attrs.update(clz_meta)

    # create the new class
    return type(name, (Codec,), attrs)
